# 6502profiler

This software is in essence an emulator for the MOS 6502, 6510 (and in future versions the 65C02) microprocessors. In contrast to the plethora of 
emulators that already exist for these microprocessors it does not aim to emulate an existing retro computer with all its features like graphics 
and sound. It is rather intended to be a development tool for optimizing (and in the future verifying) the implementation of pure algorithms on these
old computers. To state this again: No graphics or sound capabilities of any of the old computers are emulated and therefore routines like that can 
not be optimized by using `6502profiler`.

`6502profiler` reads a binary as for instance created by the `ACME` macro assembler and executes it inside the emulator. While running the program
it counts the nunber of clock cycles that are used up during execution. On top of that it can be used to identify "hot spots" in the program because
it keeps track of how many times each memory cell is accessed (i.e. read and/or written).

# How to use `6502profiler`

`6502profiler` has a command line interface. The first parameter is a so called command. Currently only the `profile` command is implemented.
It understands the following command line options:

```
./6502profiler profile -h
Usage of 6502profiler profile:
  -label string
    	Path to the label file generated by the ACME assembler
  -out string
    	Path to the out file that holds the generated data
  -prcnt uint
    	Percentage used to determine cut off value (default 10)
  -prg string
    	Path to the program to run
  -strategy string
    	Strategy to determine cutoff value (default "median")
```

The most important option is the `-prg` option which can be used to specify the binary to run. It is expected that the first two bytes
of the binary contain the load address in the usual form (lo byte first). It is also expected that exeution of the program will start at
this address. The final instruction in a program that is run by `6502profiler` has to be `BRK` and not `RTS`.

If the `-out` option is specified `6502profiler` outputs statistical data about the current program execution. The output contains two
types of lines. Label lines and address lines. The following example illustrates a label line followed by two address lines.

```
SQ_TAB_LSB
     0803: 00 50350
     0804: 01 1056087
###  0805: 8A 5591244
``` 

Label lines are created by the data contained in the symbol list file generated by the `ACME` macro assember when the `-l` option is
used with `ACME`. The path to this file has to be provided through the `-label` option of `6502profiler`. Label lines serve as a basic
link between the output of `6502profiler` and the source code of the program that is evaluated. An address line contains an address 
followed by a colon. This address is followed by the byte stored at this memory location at the end of the execution of the program which in 
turn is follwed by the number of times the address has been accessed (read and written) by the running program. When an address line 
starts with `###` it has been accessed "more often" than is usual during program execution. 

The condition what "more often" actually is, is determined by the options `-strategy` and `-prcnt`. `-prcnt` has to be a number between
0 and 100. The value 25 for instance means that all addresses in the output are flagged which are in the top 25% percent of all access
numbers. The `-strategy` option determines what constitiutes the overall set of numbers. `median` sorts all access values and uses
the lowest value in the top `n%` (n being the value of the `-prcnt` option) as a threshold. Any other value for the `-strategy` option
sorts the access values after removing all duplicate values. In first experiments no significant differences between the two strategies
have been found. If `-out` is used, then `-label` also has to be specified. `-prcnt` and `-strategy` are optional. The default values 
are 10 and `median`.

The report file created by `ACME` when specifying the `-r` option can be used to more precisely link the output of `6502profiler`
to the assembly source code. This may serve as an example:

```
     5  0800 a922               lda #34
     6  0802 a22d               ldx #45
     7  0804 20080a             jsr mul16BitFast
     8  0807 00                 brk
     9                          
    10                          ; xy = (x^2 + y^2 - (x-y)^2)/2
    11                          ; The following tables contain the LSB and MSB of i^2 where i=0, ..., 255
    12                          SQ_TAB_LSB
    13  0808 0001040910192431...!byte $00, $01, $04, $09, $10, $19, $24, $31, $40, $51, $64, $79, $90, $A9, $C4, $E1
```

The first number is the line number in the source file. The second number is the address to which the machine language
instruction has been written in the output.

# Performance

I have used `6502profiler` to further optimize the calculation routines for my [C64](https://github.com/rmsk2/c64_mandelbrot) 
and [Commander X16](https://github.com/rmsk2/X16_mandelbrot) Mandelbrot set viewers. A C64 needs about 75 minutes to create 
the default visualization in hires mode using a program of 1827 bytes length. `6502profiler` executes this program in about
a minute. The corresponding assembler source code can be found in `testprg/fixed_test.a` and `testprg/fixed_point.a`

# Limitations

Currently all 6502/6510 addressing modes and all but one instruction are emulated. The missing instruction is `RTI` as I do not
see any use for this instruction on the purely logical level on which `6502profiler` operates. On top of that only a few
65C02 spedific addressing modes and instructions have been implemented up to this point. 

# Upcoming

- Implement a feature that allows to test assembly code where the verification is done in a scripting language (the plan is to use Lua)
- Implement the additional addressing modes and instructions of the 65C02 processor
- Implement the memory model used by the Commander X16
- Maybe implement a single stepping mode
