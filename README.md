# `6502profiler`

## Overview

This software is in essence an emulator for the MOS 6502, 6510 and the 65C02 microprocessors. In contrast to the plethora of 
emulators that already exist for these microprocessors it does not aim to emulate an existing retro computer with all its features like graphics 
and sound. It is rather intended to be a development tool for optimizing and verifying the implementation of pure algorithms on old or new
machines which use these classic microprocessors. To state this again: No graphics or sound capabilities of any kind are emulated and `6502profiler`
works an a purely logical level.

The two main use cases for `6502profiler` are unit testing for and performance analysis of 6502 assembly programs. `6502profiler` offers the 
possibility to implement tests for assembly subroutines where arranging the test data and evaluating the results is offloaded to a Lua script.

When used for performance analysis `6502profiler` executes an existing  binary inside the emulator. While running the program the number of clock 
cycles that are used up during execution are counted. Additionally `6502profiler` can be used to identify "hot spots" in the program because it also 
keeps track of how many times each byte in memory is accessed (i.e. read and/or written). 

**Caution: This is work in pogress, things will change and maybe even break.**

# How to use `6502profiler`

`6502profiler` has a command line interface. The first parameter is a so called command. Currently the following
commands are implemented.

```
The following commands are available: 
     info: Return info about program
     list: List all test cases and their descriptions
     newcase: Create a new test case skeleton
     profile: Record data about program executions
     verify: Run a test on an assembler program
     verifyall: Run all tests
```

`6502profiler` expects an installed `acme` macro assembler for most of the functionality it implements. 

## The `profile` command

This command is intended to collect and evaluate data about the performance of the program under test. It understands the following 
command line options:

```
./6502profiler profile -h
Usage of 6502profiler profile:
  -c string
    	Config file name
  -label string
    	Path to the label file generated by the ACME assembler
  -out string
    	Path to the out file that holds the generated data
  -prcnt uint
    	Percentage used to determine cut off value (default 10)
  -prg string
    	Path to the program to run
  -strategy string
    	Strategy to determine cutoff value (default "median")
```

The most important option is the `-prg` option which can be used to specify the binary to run. It is expected that the first two bytes
of the binary contain the load address in the usual form (lo byte first). It is also expected that execution of the program will start at
this address. The final instruction in a program that is run by `6502profiler` has to be `BRK` and not `RTS` as `BRK` halts the emulator.

If the `-out` option is specified `6502profiler` outputs statistical data about the current program execution. The output contains two
types of lines. Label lines and address lines. The following example illustrates a label line followed by three address lines.

```
SQ_TAB_LSB
     0803: 00 50350
     0804: 01 1056087
###  0805: 8A 5591244
``` 

Label lines are created from the data contained in the symbol list file generated by the `acme` macro assember when it is called with the 
`-l` option. The path to this file can be provided through the `-label` option of `6502profiler`. Label lines serve as a basic
link between the output of `6502profiler` and the source code of the program that is evaluated. 

An address line contains a 16 bit hex address followed by a colon. This address is followed by the byte stored at this memory location 
at the end of the execution of the program. This in turn is follwed by the number of times the address has been accessed (read and written) 
by the running program. When an address line starts with `###` the corresponding address has been accessed "more often" than is usual during 
program execution. The meaning of "more often" is defined by the options `-strategy` and `-prcnt`. 

`6502profiler`counts how often each byte is accessed during program execution and stores these so called access numbers so that they
can be evaluated after the program has teminated. If an access number for a byte in memory where a machine language program resides
is high then this means that the corresponding code is executed often and therefore optmizing these parts of the program has potentially 
a big effect on overall performance.

The option `-prcnt` has to be a number between 0 and 100 and denotes a percentage. Any value `p` results in those addresses
in the output to be flagged with `###` that have access numbers which are in the top `p` percent of all access numbers.

The `-strategy` option determines what *all* access numbers are. `median` sorts all access numbers and uses the lowest value in the top `p`% 
(`p` being the value of the `-prcnt` option) as a threshold. Any other value for the `-strategy` option sorts the access values after 
removing all duplicate values and after that determines the threshold. In first experiments no significant differences between the two strategies 
have been found. 

If `-out` is used, then `-label` also has to be specified. `-prcnt` and `-strategy` are optional. The default values for these options
are 10 and `median`. The report file created by `ACME` when specifying its `-r` option can be used to more precisely link the output of 
`6502profiler` to the assembly source code.

## The `verify` and `verifyall` commands

These commands are intended to facilitate the testing of assembly subroutines. You can see `6502profiler`
in action for this purpose in my 6502 arithmetic library [project](https://github.com/rmsk2/6502-Arithmetic).
The `verify` command can be used to run one specific test case and its command line syntax is as follows:

```
Usage of 6502profiler verify:
  -c string
    	Config file name
  -t string
    	Test case file
  -verbose
    	Give more information
```

The name of the test case file is interpreted relative to the directory specified by the `AcmeTestDir` configuration entry (see below). 
The `.json` suffix of the filename can be omitted. In order to run all test cases in that directory see the `verifyall` command as 
described below.

The general idea is to have a collection of source file which contain the assembly subroutines to test in one directory (the source 
directory as given in `AcmeSrcDir`) and additional separate assembly test driver programs in a test directory (named by `AcmeTestDir`) 
which call the routines that are to be tested in an appropriate fashion. The test drivers use the `!source` pseudo opcode of `acme` to
access routines from the source directory. The test drivers are automatically assembled (or compiled) into the test binary directory.
This directory is specified by `AcmeBinDir`.

The `verify` command then loads the test driver binary and a corresponding Lua test script. This script has to define at least
two functions `arrange` and `assert`. Before running the test driver in the emulator the `verify` command calls the `arrange`
function in the Lua script which can modify the emulator state before the test driver is run (for instance to arrange test data). 
Then the test driver is run by the emulator and when that is done the `assert`function of the test script evaluates whether
the program returned the expected result. The test is successfull if the `assert` script returns `true`.

The source files for the test driver and the Lua test script have to be referenced in a JSON test case file which has the following
format:

```
{
    "Name": "Simple loop test",
    "TestDriverSource": "test1.a",
    "TestScript": "test1.lua"
}

```

The file names are interpreted relative to the directory specified by the `AcmeTestDir` configuration entry. Here an example for a test 
driver and a test script. Let's say we want to test the subroutine `simpleLoop` defined in `test_loop.a` in the source directory. This
routine is exepcted to copy a four byte vector stored at the load addres plus three bytes to the memory starting a the load address
plus seven bytes. The test driver looks as follows and is store as `test1.a` in the test directory.

```
* = $0800

jmp testStart

!source "test_loop.a"

testStart
    jsr simpleLoop
    brk
```

It is assumed that the test driver starts its execution at the load address (specified above by the `* = $xxxx` expression). The test 
driver is assembled into a binary by `acme` in such a way that its load address is contained in the first two bytes (as usual lo byte 
first). The emulator stops when it encounters a `BRK` instruction. The corresponding Lua test script is also stored  (as `test1.lua` ) 
in the test directory:

```
test_vector = "10203040"

function arrange()
    set_memory(load_address+3, test_vector)
end

function assert()
    d = get_memory(load_address+7, 4)
    fl = get_flags()
    data_ok = (d == test_vector)
    negative_is_set = (string.find(fl, "N", 0, true) ~= nil)
    error_msg = " \n"

    res = data_ok and negative_is_set

    if not data_ok then
        error_msg = error_msg .. string.format("data wrong '%s'\n", d)
    end

    if not negative_is_set then
        error_msg = error_msg .. string.format("negative flag not set: %s\n", fl)
    end

    return res, error_msg
end
```

The `arrange` function copies the test vector into the emulator's memory before the test driver is run. After the test driver has finished the
`assert` function is called to evaluate the results. In this example it is tested whether the test vector has been copied to the correct address
and if the negative flag was set at the end of the test driver. If these conditions are not met corresponding error messages are returned.

# Structure of test scripts

Test scripts have to implement an `assert` and an `arrange` function. `arrange` is expected to take no arguments and return no value. `assert` 
also takes no arguments but has to return two values. The first one is a boolean and is set to true if the test was successfull. The second 
return value is a string and should contain some helpful message in case the test has failed. The following functions can be used in Lua to 
query and manipulate the emulator's memory nd processor state:


|Function Name| Description |
|-|-|
| `set_memory(address, hex_data)` | Store the data given in `hex_data` at address `address`| 
| `get_memory(address, length)` | Return `length` bytes from the emulator beginning with the byte at address `address` as a hex string| 
| `read_byte(address)`| Returns a single byte from memory at the given address|
| `write_byte(address, value)`| Writes a single byte to memory at the given address|
| `get_flags()` | Returns an eight character string that contains the letters `NVBDIZC-`. A letter is in the string if the corresponding flag is set|
| `set_flags(flag_data)` | Sets the value of the flag register. If `flag_data` contains any of the letters described above the corresponding flag is set. Using `""` clears all flags |
| `get_pc()` | Returns the program counter |
| `get_sp()`| Returns the stack pointer |
| `get_accu()` | Returns the value stored in the accumulator | 
| `set_accu(val)` | Stores `val` in the accu | 
| `get_xreg()` | Returns the value stored in the X register | 
| `set_xreg(val)` | Stores `val` in the X register | 
| `get_yreg()` | Returns the value stored in the Y register | 
| `set_yreg(val)` | Stores `val` in the Y register | 
| `get_cycles()` | Returns the number of clock cycles used for executing the test |


The `set_memory` and `get_memory` functions can be used to get and set blocks of emulator memory. These memory blocks are always represented as a hex string. 
On top of that the following three variables are injected into the Lua script from the Go host program:

|Variable Name| Description |
|-|-|
| `load_address` | Address to which the test driver has been laoded and from which it is run | 
| `prog_len` | Length in bytes of the loaded test driver | 
| `test_dir` | Path to the test dir which can be used with `require` to load additional scripts | 


Assigning a value to these variables remains local to the Lua test script and does not influence what is happening in the golang
host application.

# The verifyall comand

The `verifyall` command can be used to execute all test cases that are found in the `AcmeTestDir` as defined in the referenced
config file. It has the following syntax:

```
Usage of 6502profiler verifyall:
  -c string
    	Config file name
  -prexec string
    	Program to run before first test
  -verbose
    	Give more information
```

Here an example what kind of output `6502profiler verifyall -c config.json` generates

```
Executing test case '32 bit multiplication 1' ... (3180 clock cycles) OK
Executing test case '16 Bit multiplication 5' ... (98 clock cycles) OK
Executing test case '32 Bit is zero 3' ... (67 clock cycles) OK
Executing test case '32 Bit compare 5' ... (132 clock cycles) OK
Executing test case '32 bit multiplication 4' ... (3052 clock cycles) OK
Executing test case '32 Bit addition test 1' ... (166 clock cycles) OK
Executing test case '32 Bit is equal 2' ... (162 clock cycles) OK
Executing test case '32 Bit is zero 4' ... (34 clock cycles) OK
```

The `-prexec` command line option can be used to specify an assembly program that is run before the first test in order to
perform a global test setup. The program name is interpreted relative to the `AcmeTestDir` defined in the config file.

# The `newcase` command

This command can be used to create a JSON test case file, a Lua script and a test driver file in the test directory. It
uses the following command line options.  

```
Usage of 6502profiler newcase:
  -c string
    	Config file name
  -d string
    	Test description
  -p string
    	Test case file name
  -t string
    	Full name of test driver file in test dir (optional)
```

The value of `-p` is used to generate the file names of all three files in the test directory by appending the corresponding 
file endings `.json`, `.a` and `.lua`. If `-t` is specified the test driver name in the newly created test case is set to the 
value of `-t`. This value has to include the file ending (typically `.a`) and is interpreted as a file name relative to `AcmeTestDir`.

## Emulator configuration

The config is stored in a JSON file and can be referenced  through the `-c` option. The config file is structured as follows

```
{
    "Model": "6502",
    "MemSpec": "Linear64K",
    "IoMask": 45,
    "IoAddrConfig": {
        "221": "file:output.bin"   
    },
    "PreLoad": {
        "40960": "/home/martin/data/vice_roms/C64/basic",
        "57344": "/home/martin/data/vice_roms/C64/kernal"
    },    
    "AcmeBinary": "acme",
    "AcmeSrcDir": "./testprg",
    "AcmeBinDir": "./testprg/tests/bin",
    "AcmeTestDir": "./testprg/tests"
}
```

`Model` can be `6502` or `65C02`. At the moment `MemSpec` can be `Linear16K`, `Linear32K`, `Linear48K`, `Linear64K`, 
`XSixteen512K` or `XSixteen2048K`. The linear memory specifications denote a contiguous chunk of memory starting at 
address 0 with a length of 16, 32 or 64 kilobytes. The `XSixteen` memory specifications configure the emulator to use 
the memory model of the Commander X16 with either 512K oder 2048K of banked RAM. 

`IoMask` and `IoAddrConfig` can be used to configure special I/O adresses that allow to exfiltrate data 
from the emulator by means of writing to a special I/O address. 

The value in `IoMask` spcifies the hi byte of all such special addresses and each entry in `IoAddrConfig` specifies the 
corresponding lo byte of one special address as well as a name of a file to which bytes are written each time data is stored 
in that address via `sta`, `stx`, `sty` or instructions that modify data in place as for instance `inc`. In the example above 
the resulting special address is `$2ddd` ($2d=45, $dd=221). Entries for such file store addresses start with `file:` and the 
remaining string specifies the file name. If no such special addresses are needed then `IoAddrConfig` should be empty.

If you want to load binaries into the emulator's RAM before your program is run you can list these binaries in the `PreLoad`
property. Each entry is a key value pair where the key is the address to which the binary should be loaded and the value is
the name of the file which contains the binary to load. This can for instance be used to load ROM images. It has to be noted
though that these images are of limited use because `6502profiler` does not emulate any I/O, timing or interrupt behaviour.

The `AcmeBinary`entry defines the path to the `acme` program binary. `AcmeSrcDir` has to describe the path to the directory where 
the assembler source files (which do not implement the tests themselves) are stored. `AcmeTestDir` holds the directory where
the test case files, the assembler source for the test drivers and the test scripts are located. Assembled test drivers are 
stored in the directory referenced by `AcmeBinDir`.

# Performance

I have used `6502profiler` to further optimize the calculation routines for my [C64](https://github.com/rmsk2/c64_mandelbrot) 
and [Commander X16](https://github.com/rmsk2/X16_mandelbrot) Mandelbrot set viewers. A C64 needs about 75 minutes to create 
the default visualization in hires mode using a program of 1827 bytes length. `6502profiler` executes this program in about
a minute. The corresponding assembler source code can be found in `testprg/fixed_test.a` and `testprg/fixed_point.a`

# Limitations

Currently all 6502/6510 addressing modes and all but one instruction are emulated. The missing instruction is `RTI` as I do not
see any use for this instruction on the purely logical level on which `6502profiler` operates. Furthermore the 65C02 instructions
`STP` and `WAI` are also not implemented for the same reason.

# Building `6502profiler`

The software is written in Go and therefore it can be built by the usual `go build` command. Tests are provided for all
6502 instructions and can be executed through `go test ./...`.

# Upcoming

- Maybe implement a single stepping mode
